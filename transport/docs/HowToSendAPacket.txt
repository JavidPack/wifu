How to send a packet.  We need to get a response from each state machine (or current state) whether or not it is okay to send a packet (of N bytes).



Before the socket can pass a packet to the UDPInterface, we must get approval from all FSMs.
This document contains Randy's ideas on how we might want to do this:

A) Trylock type thing
B) Pass in a sem that the caller waits on, then the state posts on it when it is determined that it is allowed to send the packet.
C) Queue at each state that state reads from, sleeps otherwise
D) Socket has counting semaphore which each state machine can post on indicating number of [bytes|packets] it can handle.  Socket takes the [min] of all these values.  Socket waits on that sem.  As a subpoint, we would likely need to redefine what a counting semaphore is so it can support waiting/posting on more than one [byte] at a time.  As a variant of this, we could loop through each FSMs send semaphore and wait on each one.
E) Machine (state) blocks itself until it can send.


10-11-10
Two potential models:

1) 
SocketComponent.allow(Packet * p) simply answers the question whether we can send p.
SocketComponent.send(Packet * p) updates the packed and updates the SocketComponent.

Issues: 
May do work twice

2)
SocketComponent.send(Packet * p) updates the packet and the SocketComponent keeping a copy of the next state.
SocketComponent.update(Packet * p) changes the state of the SocketComponent (and the Packet) to the next state.

Issues:
Duplicate information
Likely harder to understand/implement
Less Modular


Proposed Solution:
Each FSM's send operation will implement the template pattern.  We can then control some base functionallity in each send.  Namely we want to control what happens immediately following a module saying it is okay to send a packet.  (It will be up to each module to wait, if necessary, before finishing the method.)  After the 'okay' is given by each FSM, the FSM posts on a coutning semaphore and then a signal is sent (two options on how to do this, discussed below) which will check to see if all FSM send functions have posted on it (this way we don't need to be sequential in processing a packet).  The signal handler will read the semaphore's value to see how many posts have occured.  If the value is equal to the number of FSMs, another signal will be sent to the thread which called send on each FSM which will indiate to it (the calling thread) that all calls have successfully completed and the packet may actually be sent to the UDPInterface.

Two methods for signaling:
1) use the built-in signal/raise functions.  Each method simply raises a signal after posting to the semaphore.  The signal handler then checks to see if the counting semaphore is equal to the number of FSMs, if so, it posts on a flag which will then allow the packet to be sent to the UDPInterface.
Benefits: 
No extra thread needed.
Avoid using an extra semaphore.
Drawbacks:
Unclear of performance compared with using a semaphore.

2) Post on a semaphore (instead of raising a signal).  A separate thread (running a while(true) loop), waits on the semaphore.  Upon any FSM posting, it will check to see if the number in the counting semaphore is equal to the number of FSMs, if so, it will post on the flag.
Benefits:
Avoid system calls. (Although a raise is handled within the application.)
Drawbacks:
Must have another semaphore
Must have a separate thread running which exclusively handles this operation (context switching).
